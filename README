usage: memory_tracer.py [-h] [--workload_path WORKLOAD_PATH]
                        [--analysis_tool_path ANALYSIS_TOOL_PATH]
                        [--trace_only_CPL3_code_GMBE]
                        [--log_of_GMBE_block_len LOG_OF_GMBE_BLOCK_LEN]
                        [--log_of_GMBE_tracing_ratio LOG_OF_GMBE_TRACING_RATIO]
                        [--dont_exit_qemu_when_done] [--print_trace_info]
                        [--verbose]
                        guest_image_path snapshot_name workload_runner_path
                        host_password qemu_with_GMBEOO_path

Run a workload on the QEMU guest while writing optimized GMBE trace records to a FIFO.

(memory_tracer.py assumes you have already run build.py successfully.)

GMBE is short for guest_mem_before_exec. This is an event in upstream QEMU 3.0.0 that occurs on every attempt of the QEMU guest to access a virtual memory address.

We optimized QEMU's tracing code for the case in which only trace records of GMBE are gathered (we call it GMBE only optimization - GMBEOO).
When GMBEOO is enabled, a trace record is structured as follows:

struct GMBEOO_TraceRecord {
    uint8_t size_shift : 3; /* interpreted as "1 << size_shift" bytes */
    bool    sign_extend: 1; /* whether it is a sign-extended operation */
    uint8_t endianness : 1; /* 0: little, 1: big */
    bool    store      : 1; /* whether it is a store operation */
    uint8_t cpl        : 2;
    uint64_t unused2   : 56;
    uint64_t virt_addr : 64;
};

memory_tracer.py also prints the workload info (in case it isn't the empty string).
In case --analysis_tool_path is specified, memory_tracer.py also prints the output of the analysis tool.

Either workload_runner or the workload itself must do the following:
1. Print "-----begin workload info-----".
2. Print runtime info of the workload. This info will be written to stdout, as well as passed as cmd arguments to the analysis tool in case of --analysis_tool_path was specified. (Print nothing if you don't need any runtime info.)
3. Print "-----end workload info-----".
4. Print "Ready to trace. Press enter to continue" when you wish the tracing to start.
5. Wait until enter is pressed, and only then start executing the code you wish to run while tracing.
6. Print "Stop tracing" when you wish the tracing to stop.
(If any of the messages isn't printed, it will probably seem like memory_tracer.py is stuck.)

Note that workload_runner can also be an ELF that includes the workload and the aforementioned prints.

If --analysis_tool_path is specified, the provided analysis tool must do the following:
1. Print "Ready to analyze" when you wish the tracing to start.
2. Register a handler for the signal SIGUSR1 (e.g. by calling the `signal` syscall). The handler must:
  a. Print "-----begin analysis output-----".
  b. Print the output of the analysis tool.
  c. Print "-----end analysis output-----".
analysis tool (If any of the messages isn't printed, it will probably seem like memory_tracer.py is stuck.)

positional arguments:
  guest_image_path      The path of the qcow2 file which is the image of the
                        guest.
  snapshot_name         The name of the snapshot saved by the monitor command
                        `savevm`, which was specially constructed for running
                        a workload with GMBE tracing.
  workload_runner_path  The path of the workload_runner script.
                        workload_runner would be downloaded and executed by
                        the qemu guest.
  host_password         If you donâ€™t like the idea of your password in plain
                        text, feel free to patch our code so that scp would
                        use keys instead.
  qemu_with_GMBEOO_path
                        The path of qemu_with_GMBEOO.

optional arguments:
  -h, --help            show this help message and exit
  --workload_path WORKLOAD_PATH
                        The path of a file/directory that would be downloaded
                        by the qemu guest into its home directory, and named
                        workload. (This is meant for convenience, e.g. in case
                        your workload includes more than a single file. If
                        your workload is heavy and unchanging, it would
                        probably be faster to download it to the QEMU guest,
                        use `savevm`, and later pass that snapshot's name as
                        the snapshot_name argument.
  --analysis_tool_path ANALYSIS_TOOL_PATH
                        Path of an analysis tool that would start executing
                        before the tracing starts.
  --trace_only_CPL3_code_GMBE
                        If specified, qemu would only trace memory accesses by
                        CPL3 code. Otherwise, qemu would trace all accesses.
  --log_of_GMBE_block_len LOG_OF_GMBE_BLOCK_LEN
                        Log of the length of a GMBE_block, i.e. the number of
                        GMBE events in a GMBE_block. (It is used when
                        determining whether to trace a GMBE event.)
  --log_of_GMBE_tracing_ratio LOG_OF_GMBE_TRACING_RATIO
                        Log of the ratio between the number of blocks of GMBE
                        events we trace to the total number of blocks. E.g. if
                        GMBE_tracing_ratio is 16, we trace 1 block, then skip
                        15 blocks, then trace 1, then skip 15, and so on...
  --dont_exit_qemu_when_done
                        If specified, qemu won't be terminated after running
                        the workload, and you would be able to use the
                        terminal to send monitor commands, as well as use the
                        qemu guest directly, in case you have a graphic
                        interface (which isn't the case if you are running
                        memory_tracer.py on a remote server using ssh). Still,
                        you would be able to use the qemu guest, e.g. by
                        connecting to it using ssh. Remember that the guest
                        would probably be in the state it was before running
                        the workload, which is probably a quite uncommon
                        state, e.g. /dev/tty is overwritten by /dev/ttyS0.
  --print_trace_info    If specified, memory_tracer.py would also print some
                        additional trace info:
                        num_of_events_waiting_in_trace_buf (only if it isn't
                        0, which probably shouldn't happen);
                        num_of_GMBE_events_since_enabling_GMBEOO (excluding
                        non-CPL3 GMBE events, in case
                        --trace_only_CPL3_code_GMBE was specified);
                        num_of_events_written_to_trace_buf;
                        num_of_missing_events (i.e.
                        `num_of_events_written_to_trace_buf -
                        num_of_events_written_to_trace_file -
                        num_of_events_waiting_in_trace_buf`, but only if it
                        isn't 0, which is probably a bug in qemu_with_GMBEOO);
                        actual_tracing_ratio (i.e.
                        num_of_GMBE_events_since_enabling_GMBEOO /
                        num_of_events_written_to_trace_buf);
                        num_of_dropped_events (i.e. events such that when
                        qemu_with_GMBEOO tried to write them to the trace_buf,
                        it was full, so they were discarded. This shouldn't
                        happen normally.
  --verbose, -v         If specified, debug messages are printed.
